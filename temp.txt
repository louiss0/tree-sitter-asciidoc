#include "tree_sitter/parser.h"
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

enum TokenType {
  EXAMPLE_FENCE_START,
  EXAMPLE_FENCE_END,
  LISTING_FENCE_START,
  LISTING_FENCE_END,
  LITERAL_FENCE_START,
  LITERAL_FENCE_END,
  QUOTE_FENCE_START,
  QUOTE_FENCE_END,
  SIDEBAR_FENCE_START,
  SIDEBAR_FENCE_END,
  PASSTHROUGH_FENCE_START,
  PASSTHROUGH_FENCE_END,
  OPENBLOCK_FENCE_START,
  OPENBLOCK_FENCE_END,
  LIST_CONTINUATION,
  AUTOLINK_BOUNDARY,
  ATTRIBUTE_LIST_START,
  UNORDERED_LIST_MARKER,
  ORDERED_LIST_MARKER,
  DESCRIPTION_DELIMITER,
  PLAIN_COLON,
  INLINE_MACRO_NAME,
  BLOCK_MACRO_NAME,
  INLINE_MACRO_MARKER,
  BLOCK_MACRO_MARKER,
  DELIMITED_BLOCK_CONTENT_LINE,
  THEMATIC_BREAK,
  PAGE_BREAK,
  PLAIN_ASTERISK,
  PLAIN_UNDERSCORE,
  PLAIN_DASH,
  PLAIN_QUOTE,
  PLAIN_CARET,
  PLAIN_DOUBLE_QUOTE,
  INTERNAL_XREF_OPEN,
  INTERNAL_XREF_CLOSE,
};

typedef struct {
  uint8_t block_depth;
  uint32_t last_colon_column;
  bool last_colon_valid;
} ScannerState;

static inline char to_lower_ascii(char c) {
  if (c >= 'A' && c <= 'Z') {
    return (char)(c - 'A' + 'a');
  }
  return c;
}

static bool name_equals(const char *lhs, size_t lhs_length, const char *rhs) {
  size_t i = 0;
  for (; rhs[i] && i < lhs_length; i++) {
    if (lhs[i] != rhs[i]) {
      return false;
    }
  }
  return i == lhs_length && rhs[i] == '\0';
}

static bool is_conditional_directive_name(const char *name, size_t length) {
  return name_equals(name, length, "ifdef") ||
         name_equals(name, length, "ifndef") ||
         name_equals(name, length, "ifeval");
}

static inline bool is_newline(int32_t c) { return c == '\n' || c == '\r'; }

static inline bool is_space(int32_t c) { return c == ' ' || c == '\t'; }

static inline bool is_word_char(int32_t c) {
  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_';
}

static inline bool is_macro_name_char(int32_t c) {
  if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
    return true;
  }
  switch (c) {
    case '!':
    case '$':
    case '.':
    case ',':
    case '\'':
    case '"':
    case '(':
    case ')':
    case '+':
    case '/':
    case '=':
    case '%':
    case '?':
    case '#':
    case '{':
    case '}':
      return true;
    default:
      return false;
  }
}

static inline void advance(TSLexer *lexer) { lexer->advance(lexer, false); }

static inline void skip(TSLexer *lexer) { lexer->advance(lexer, true); }

static inline void push_block(ScannerState *state) {
  if (state && state->block_depth < UINT8_MAX) {
    state->block_depth++;
  }
}

static inline void pop_block(ScannerState *state) {
  if (state && state->block_depth > 0) {
    state->block_depth--;
  }
}

static inline void note_block_transition(ScannerState *state, enum TokenType token) {
  switch (token) {
    case EXAMPLE_FENCE_START:
    case LISTING_FENCE_START:
    case LITERAL_FENCE_START:
    case QUOTE_FENCE_START:
    case SIDEBAR_FENCE_START:
    case PASSTHROUGH_FENCE_START:
    case OPENBLOCK_FENCE_START:
      push_block(state);
      break;
    case EXAMPLE_FENCE_END:
    case LISTING_FENCE_END:
    case LITERAL_FENCE_END:
    case QUOTE_FENCE_END:
    case SIDEBAR_FENCE_END:
    case PASSTHROUGH_FENCE_END:
    case OPENBLOCK_FENCE_END:
      pop_block(state);
      break;
    default:
      break;
  }
}

static inline void note_plain_colon(ScannerState *state, uint32_t column) {
  if (state) {
    state->last_colon_column = column;
    state->last_colon_valid = true;
  }
}

static inline void clear_plain_colon(ScannerState *state) {
  if (state) {
    state->last_colon_valid = false;
  }
}

static bool consume_line_break(TSLexer *lexer) {
  if (lexer->lookahead == '\r') {
    advance(lexer);
    if (lexer->lookahead == '\n') {
      advance(lexer);
    }
    return true;
  }
  if (lexer->lookahead == '\n') {
    advance(lexer);
    return true;
  }
  if (lexer->eof(lexer)) {
    return true;
  }
  return false;
}

static bool scan_repeated_fence(TSLexer *lexer, char marker, unsigned min_count) {
  if (lexer->get_column(lexer) != 0 || lexer->lookahead != marker) {
    return false;
  }

  unsigned count = 0;
  while (lexer->lookahead == marker) {
    advance(lexer);
    count++;
  }

  if (count < min_count) {
    return false;
  }

  while (is_space(lexer->lookahead)) {
    advance(lexer);
  }

  return consume_line_break(lexer);
}

static bool scan_ordered_list_marker(TSLexer *lexer) {
  if (lexer->get_column(lexer) != 0) {
    return false;
  }

  if (lexer->lookahead == '.') {
    unsigned dot_count = 0;
    while (lexer->lookahead == '.') {
      advance(lexer);
      dot_count++;
    }
    if (dot_count == 0) {
      return false;
    }
  } else if (lexer->lookahead >= '0' && lexer->lookahead <= '9') {
    while (lexer->lookahead >= '0' && lexer->lookahead <= '9') {
      advance(lexer);
    }
    if (lexer->lookahead != '.') {
      return false;
    }
    advance(lexer);
    if (lexer->lookahead == '.') {
      return false;
    }
  } else {
    return false;
  }

  bool saw_space = false;
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    saw_space = true;
    advance(lexer);
  }

  if (!saw_space) {
    return false;
  }

  lexer->result_symbol = ORDERED_LIST_MARKER;
  return true;
}

static bool scan_star_prefix(TSLexer *lexer, const bool *valid_symbols, ScannerState *state) {
  if (lexer->lookahead != '*') {
    return false;
  }

  bool wants_list = valid_symbols[UNORDERED_LIST_MARKER];
  bool wants_sidebar =
    valid_symbols[SIDEBAR_FENCE_START] || valid_symbols[SIDEBAR_FENCE_END];
  bool wants_thematic = valid_symbols[THEMATIC_BREAK];

  if (!wants_list && !wants_sidebar && !wants_thematic) {
    return false;
  }

  advance(lexer);
  lexer->mark_end(lexer);

  unsigned count = 1;
  while (lexer->lookahead == '*') {
    advance(lexer);
    count++;
  }

  unsigned spaces = 0;
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    advance(lexer);
    spaces++;
  }

  bool at_line_end = is_newline(lexer->lookahead) || lexer->lookahead == 0;

  if (count >= 4 && at_line_end &&
      (valid_symbols[SIDEBAR_FENCE_START] || valid_symbols[SIDEBAR_FENCE_END])) {
    consume_line_break(lexer);
    lexer->result_symbol = valid_symbols[SIDEBAR_FENCE_END] ? SIDEBAR_FENCE_END : SIDEBAR_FENCE_START;
    note_block_transition(state, lexer->result_symbol);
    return true;
  }

  if (count >= 3 && at_line_end && valid_symbols[THEMATIC_BREAK]) {
    consume_line_break(lexer);
    lexer->result_symbol = THEMATIC_BREAK;
    return true;
  }

  if (count == 1 && spaces > 0 && valid_symbols[UNORDERED_LIST_MARKER]) {
    lexer->result_symbol = UNORDERED_LIST_MARKER;
    return true;
  }

  return false;
}

static bool scan_dash_prefix(TSLexer *lexer, const bool *valid_symbols, ScannerState *state) {
  if (lexer->lookahead != '-') {
    return false;
  }

  bool wants_list = valid_symbols[UNORDERED_LIST_MARKER];
  bool wants_listing =
    valid_symbols[LISTING_FENCE_START] || valid_symbols[LISTING_FENCE_END];
  bool wants_open_block =
    valid_symbols[OPENBLOCK_FENCE_START] || valid_symbols[OPENBLOCK_FENCE_END];

  if (!wants_list && !wants_listing && !wants_open_block) {
    return false;
  }

  advance(lexer);
  lexer->mark_end(lexer);

  unsigned count = 1;
  while (lexer->lookahead == '-') {
    advance(lexer);
    count++;
  }

  unsigned spaces = 0;
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    advance(lexer);
    spaces++;
  }

  bool at_line_end = is_newline(lexer->lookahead) || lexer->lookahead == 0;

  if (at_line_end && count >= 4 && (valid_symbols[LISTING_FENCE_START] || valid_symbols[LISTING_FENCE_END])) {
    consume_line_break(lexer);
    lexer->result_symbol = valid_symbols[LISTING_FENCE_END] ? LISTING_FENCE_END : LISTING_FENCE_START;
    note_block_transition(state, lexer->result_symbol);
    return true;
  }

  if (at_line_end && count == 2 && (valid_symbols[OPENBLOCK_FENCE_START] || valid_symbols[OPENBLOCK_FENCE_END])) {
    consume_line_break(lexer);
    lexer->result_symbol = valid_symbols[OPENBLOCK_FENCE_END] ? OPENBLOCK_FENCE_END : OPENBLOCK_FENCE_START;
    note_block_transition(state, lexer->result_symbol);
    return true;
  }

  if (count == 1 && spaces > 0 && valid_symbols[UNORDERED_LIST_MARKER]) {
    lexer->result_symbol = UNORDERED_LIST_MARKER;
    return true;
  }

  return false;
}

static bool scan_plus_prefix(TSLexer *lexer, const bool *valid_symbols, ScannerState *state) {
  if (lexer->lookahead != '+') {
    return false;
  }

  unsigned count = 0;
  while (lexer->lookahead == '+') {
    advance(lexer);
    count++;
  }

  unsigned spaces = 0;
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    advance(lexer);
    spaces++;
  }

  bool at_line_end = is_newline(lexer->lookahead) || lexer->lookahead == 0;

  if (count >= 4 && at_line_end &&
      (valid_symbols[PASSTHROUGH_FENCE_START] || valid_symbols[PASSTHROUGH_FENCE_END])) {
    consume_line_break(lexer);
    lexer->result_symbol = valid_symbols[PASSTHROUGH_FENCE_END] ? PASSTHROUGH_FENCE_END : PASSTHROUGH_FENCE_START;
    note_block_transition(state, lexer->result_symbol);
    return true;
  }

  if (count == 1 && at_line_end && valid_symbols[LIST_CONTINUATION]) {
    consume_line_break(lexer);
    lexer->result_symbol = LIST_CONTINUATION;
    return true;
  }

  return false;
}

static bool scan_description_delimiter(
  TSLexer *lexer,
  const bool *valid_symbols,
  ScannerState *state) {
  if (lexer->lookahead != ':') {
    return false;
  }

  uint32_t column = lexer->get_column(lexer);
  if (column == 0) {
    return false;
  }

  if (state && state->last_colon_valid && state->last_colon_column + 1 == column) {
    return false;
  }

  advance(lexer);
  lexer->mark_end(lexer);

  if (lexer->lookahead != ':') {
    if (valid_symbols[PLAIN_COLON]) {
      lexer->result_symbol = PLAIN_COLON;
      note_plain_colon(state, column);
      return true;
    }
    return false;
  }

  advance(lexer);

  bool saw_space = false;
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    saw_space = true;
    advance(lexer);
  }

  if (!saw_space) {
    if (valid_symbols[PLAIN_COLON]) {
      lexer->result_symbol = PLAIN_COLON;
      note_plain_colon(state, column);
      return true;
    }
    return false;
  }

  lexer->mark_end(lexer);
  clear_plain_colon(state);
  lexer->result_symbol = DESCRIPTION_DELIMITER;
  return true;
}

static bool scan_attribute_list(TSLexer *lexer) {
  if (lexer->get_column(lexer) != 0 || lexer->lookahead != '[') {
    return false;
  }

  advance(lexer);
  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    advance(lexer);
  }

  if (lexer->lookahead == '#') {
    return false;
  }

  bool saw_content = false;

  while (lexer->lookahead && !is_newline(lexer->lookahead)) {
    if (lexer->lookahead == ']') {
      advance(lexer);
      while (is_space(lexer->lookahead)) {
        advance(lexer);
      }
      if (lexer->lookahead == '#' || lexer->lookahead == '+') {
        return false;
      }
      return consume_line_break(lexer);
    }
    saw_content = true;
    advance(lexer);
  }

  return false;
}

static bool scan_block_content_line(TSLexer *lexer) {
  bool saw_non_ws = false;

  while (lexer->lookahead && !is_newline(lexer->lookahead)) {
    if (!is_space(lexer->lookahead)) {
      saw_non_ws = true;
    }
    advance(lexer);
  }

  if (!saw_non_ws) {
    return false;
  }

  consume_line_break(lexer);
  return true;
}

static bool scan_thematic_break(TSLexer *lexer, const bool *valid_symbols) {
  if (!valid_symbols[THEMATIC_BREAK] || lexer->get_column(lexer) != 0) {
    return false;
  }

  const int32_t marker = lexer->lookahead;
  if (marker != '\'' && marker != '_') {
    return false;
  }

  unsigned count = 0;
  while (lexer->lookahead == marker) {
    advance(lexer);
    count++;
  }

  if (count < 3) {
    return false;
  }

  while (is_space(lexer->lookahead)) {
    advance(lexer);
  }

  if (!consume_line_break(lexer)) {
    return false;
  }

  lexer->result_symbol = THEMATIC_BREAK;
  return true;
}

static bool scan_page_break(TSLexer *lexer, const bool *valid_symbols) {
  if (!valid_symbols[PAGE_BREAK] || lexer->get_column(lexer) != 0 || lexer->lookahead != '<') {
    return false;
  }

  unsigned count = 0;
  while (lexer->lookahead == '<') {
    advance(lexer);
    count++;
  }

  if (count < 3) {
    return false;
  }

  while (is_space(lexer->lookahead)) {
    advance(lexer);
  }

  if (!consume_line_break(lexer)) {
    return false;
  }

  lexer->result_symbol = PAGE_BREAK;
  return true;
}

static bool scan_for_closing_delimiter(TSLexer *lexer, int32_t delimiter) {
  bool escaped = false;

  while (lexer->lookahead) {
    if (lexer->lookahead == delimiter && !escaped) {
      return true;
    }
    if (is_newline(lexer->lookahead)) {
      return false;
    }
    if (!escaped && lexer->lookahead == '\\') {
      escaped = true;
      advance(lexer);
      continue;
    }
    escaped = false;
    advance(lexer);
  }

  return false;
}

static bool validate_block_macro_tail(TSLexer *lexer) {
  while (true) {
    int32_t c = lexer->lookahead;

    if (c == '\\') {
      advance(lexer);
      if (lexer->lookahead == 0 || is_newline(lexer->lookahead)) {
        return false;
      }
      advance(lexer);
      continue;
    }

    if (c == ']') {
      advance(lexer);
      break;
    }

    if (c == 0 || is_newline(c)) {
      return false;
    }

    advance(lexer);
  }

  while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
    advance(lexer);
  }

  if (lexer->lookahead == '\r' || lexer->lookahead == '\n' || lexer->eof(lexer)) {
    return true;
  }

  return false;
}

static bool validate_inline_macro_tail(TSLexer *lexer) {
  while (true) {
    int32_t c = lexer->lookahead;

    if (c == '\\') {
      advance(lexer);
      if (lexer->lookahead == 0 || is_newline(lexer->lookahead)) {
        return false;
      }
      advance(lexer);
      continue;
    }

    if (c == ']') {
      return true;
    }

    if (c == 0 || is_newline(c)) {
      return false;
    }

    advance(lexer);
  }
}

static bool scan_macro_name(TSLexer *lexer, const bool *valid_symbols) {
  const bool wants_block = valid_symbols[BLOCK_MACRO_NAME];
  const bool wants_inline = valid_symbols[INLINE_MACRO_NAME];

  if (!wants_block && !wants_inline) {
    return false;
  }

  if (!is_macro_name_char(lexer->lookahead)) {
    return false;
  }

  char name_buffer[64];
  size_t name_length = 0;

  while (is_macro_name_char(lexer->lookahead)) {
    if (name_length < sizeof(name_buffer) - 1) {
      name_buffer[name_length++] = to_lower_ascii((char)lexer->lookahead);
    }
    advance(lexer);
    lexer->mark_end(lexer);
  }

  name_buffer[name_length] = '\0';

  if (is_conditional_directive_name(name_buffer, name_length)) {
    return false;
  }

  if (lexer->lookahead != ':') {
    return false;
  }

  advance(lexer);

  bool is_block_macro = false;
  if (lexer->lookahead == ':') {
    is_block_macro = true;
    advance(lexer);
  }

  if (is_block_macro && !wants_block) {
    return false;
  }

  if (!is_block_macro && !wants_inline) {
    return false;
  }

  while (true) {
    if (lexer->lookahead == '\\') {
      advance(lexer);
      if (lexer->lookahead == 0 || is_newline(lexer->lookahead)) {
        return false;
      }
      advance(lexer);
      continue;
    }

    if (lexer->lookahead == '[') {
      advance(lexer);
      bool ok = is_block_macro ? validate_block_macro_tail(lexer) : validate_inline_macro_tail(lexer);
      if (!ok) {
        return false;
      }
      break;
    }

    if (lexer->lookahead == 0 || is_newline(lexer->lookahead)) {
      return false;
    }

    advance(lexer);
  }

  lexer->result_symbol = is_block_macro ? BLOCK_MACRO_NAME : INLINE_MACRO_NAME;
  return true;
}

static bool scan_macro_marker_or_colon(
  TSLexer *lexer,
  const bool *valid_symbols,
  ScannerState *state) {
  if (lexer->lookahead != ':') {
    return false;
  }

  uint32_t start_column = lexer->get_column(lexer);

  if (start_column == 0) {
    if (valid_symbols[PLAIN_COLON]) {
      advance(lexer);
      lexer->result_symbol = PLAIN_COLON;
      note_plain_colon(state, start_column);
      return true;
    }
    return false;
  }

  advance(lexer);
  bool is_block_macro = false;

  if (lexer->lookahead == ':') {
    is_block_macro = true;
    advance(lexer);
  }

  lexer->mark_end(lexer);

  const bool wants_inline = !is_block_macro && valid_symbols[INLINE_MACRO_MARKER];
  const bool wants_block = is_block_macro && valid_symbols[BLOCK_MACRO_MARKER];

  if (wants_inline || wants_block) {
    while (lexer->lookahead && !is_newline(lexer->lookahead)) {
      if (lexer->lookahead == '[') {
        advance(lexer);
        lexer->mark_end(lexer);

        if (wants_block && !validate_block_macro_tail(lexer)) {
          return false;
        }

        if (wants_inline && !validate_inline_macro_tail(lexer)) {
          return false;
        }
        lexer->result_symbol = wants_block ? BLOCK_MACRO_MARKER : INLINE_MACRO_MARKER;
        clear_plain_colon(state);
        return true;
      }

      advance(lexer);
    }
  }

  if (valid_symbols[PLAIN_COLON]) {
    lexer->result_symbol = PLAIN_COLON;
    note_plain_colon(state, start_column);
    return true;
  }

  return false;
}

static inline bool emit_plain_punctuation(
  TSLexer *lexer,
  const bool *valid_symbols,
  enum TokenType token,
  int32_t punct) {
  if (!valid_symbols[token] || lexer->lookahead != punct) {
    return false;
  }

  advance(lexer);
  lexer->result_symbol = token;
  return true;
}

static bool emit_plain_colon(TSLexer *lexer, const bool *valid_symbols, ScannerState *state) {
  if (!valid_symbols[PLAIN_COLON] || lexer->lookahead != ':') {
    return false;
  }

  uint32_t column = lexer->get_column(lexer);
  advance(lexer);
  lexer->result_symbol = PLAIN_COLON;
  note_plain_colon(state, column);
  return true;
}

static bool scan_plain_caret(TSLexer *lexer, const bool *valid_symbols) {
  if (!valid_symbols[PLAIN_CARET] || lexer->lookahead != '^') {
    return false;
  }

  advance(lexer);
  lexer->mark_end(lexer);

  int32_t next = lexer->lookahead;
  if (next == 0 || is_newline(next) || is_space(next) || next == '^') {
    lexer->result_symbol = PLAIN_CARET;
    return true;
  }

  if (scan_for_closing_delimiter(lexer, '^')) {
    return false;
  }

  lexer->result_symbol = PLAIN_CARET;
  return true;
}

static bool scan_internal_xref_open(TSLexer *lexer, const bool *valid_symbols) {
  if (!valid_symbols[INTERNAL_XREF_OPEN]) {
    return false;
  }

  while (is_space(lexer->lookahead)) {
    skip(lexer);
  }

  if (lexer->lookahead != '<') {
    return false;
  }

  lexer->mark_end(lexer);
  advance(lexer);
  if (lexer->lookahead != '<') {
    return false;
  }
  advance(lexer);
  lexer->mark_end(lexer);

  bool has_target = false;
  bool has_text = false;
  bool saw_comma = false;

  while (lexer->lookahead) {
    int32_t c = lexer->lookahead;

    if (is_newline(c)) {
      return false;
    }

    if (c == '>') {
      advance(lexer);
      if (lexer->lookahead == '>') {
        if (!has_target) {
          return false;
        }
        if (saw_comma && !has_text) {
          return false;
        }
        lexer->result_symbol = INTERNAL_XREF_OPEN;
        return true;
      }
      return false;
    }

    if (c == '<') {
      return false;
    }

    if (c == ',' && !saw_comma) {
      if (!has_target) {
        return false;
      }
      saw_comma = true;
      advance(lexer);
      continue;
    }

    if (c == ',' && saw_comma) {
      return false;
    }

    if (saw_comma) {
      has_text = true;
    } else {
      has_target = true;
    }

    advance(lexer);
  }

  return false;
}

static bool scan_internal_xref_close(TSLexer *lexer, const bool *valid_symbols) {
  if (!valid_symbols[INTERNAL_XREF_CLOSE] || lexer->lookahead != '>') {
    return false;
  }

  lexer->mark_end(lexer);
  advance(lexer);
  if (lexer->lookahead != '>') {
    return false;
  }
  advance(lexer);
  lexer->mark_end(lexer);
  lexer->result_symbol = INTERNAL_XREF_CLOSE;
  return true;
}

static bool scan_plain_inline_punctuation(
  TSLexer *lexer,
  const bool *valid_symbols,
  ScannerState *state) {
  return scan_plain_caret(lexer, valid_symbols) ||
         emit_plain_colon(lexer, valid_symbols, state) ||
         emit_plain_punctuation(lexer, valid_symbols, PLAIN_ASTERISK, '*') ||
         emit_plain_punctuation(lexer, valid_symbols, PLAIN_UNDERSCORE, '_') ||
         emit_plain_punctuation(lexer, valid_symbols, PLAIN_DASH, '-') ||
         emit_plain_punctuation(lexer, valid_symbols, PLAIN_QUOTE, '\'') ||
         emit_plain_punctuation(lexer, valid_symbols, PLAIN_DOUBLE_QUOTE, '"');
}


void *tree_sitter_asciidoc_external_scanner_create(void) {
  ScannerState *state = (ScannerState *)calloc(1, sizeof(ScannerState));
  return state;
}

unsigned tree_sitter_asciidoc_external_scanner_serialize(void *payload, char *buffer) {
  ScannerState *state = (ScannerState *)payload;
  if (!state) {
    return 0;
  }
  buffer[0] = (char)state->block_depth;
  memcpy(&buffer[1], &state->last_colon_column, sizeof(uint32_t));
  buffer[5] = state->last_colon_valid ? 1 : 0;
  return 6;
}

void tree_sitter_asciidoc_external_scanner_deserialize(void *payload, const char *buffer, unsigned length) {
  ScannerState *state = (ScannerState *)payload;
  if (!state) {
    return;
  }
  state->block_depth = length > 0 ? (uint8_t)buffer[0] : 0;
  if (length >= 6) {
    memcpy(&state->last_colon_column, &buffer[1], sizeof(uint32_t));
    state->last_colon_valid = buffer[5] != 0;
  } else {
    state->last_colon_column = 0;
    state->last_colon_valid = false;
  }
}

void tree_sitter_asciidoc_external_scanner_destroy(void *payload) {
  if (payload) {
    free(payload);
  }
}

bool tree_sitter_asciidoc_external_scanner_scan(void *payload, TSLexer *lexer, const bool *valid_symbols) {
  ScannerState *state = (ScannerState *)payload;

  if (lexer->eof(lexer)) {
    return false;
  }

  if ((valid_symbols[BLOCK_MACRO_NAME] || valid_symbols[INLINE_MACRO_NAME]) &&
      scan_macro_name(lexer, valid_symbols)) {
    return true;
  }

  if (valid_symbols[DESCRIPTION_DELIMITER] && scan_description_delimiter(lexer, valid_symbols, state)) {
    return true;
  }

  if ((valid_symbols[BLOCK_MACRO_MARKER] || valid_symbols[INLINE_MACRO_MARKER] || valid_symbols[PLAIN_COLON]) &&
      scan_macro_marker_or_colon(lexer, valid_symbols, state)) {
    return true;
  }

  if (lexer->get_column(lexer) == 0) {
    if (valid_symbols[ATTRIBUTE_LIST_START] && scan_attribute_list(lexer)) {
      lexer->result_symbol = ATTRIBUTE_LIST_START;
      return true;
    }

    if (lexer->lookahead == '*' && scan_star_prefix(lexer, valid_symbols, state)) {
      return true;
    }

    if (lexer->lookahead == '-' && scan_dash_prefix(lexer, valid_symbols, state)) {
      return true;
    }

    if (lexer->lookahead == '+' && scan_plus_prefix(lexer, valid_symbols, state)) {
      return true;
    }

    if (scan_thematic_break(lexer, valid_symbols)) {
      return true;
    }

    if (scan_page_break(lexer, valid_symbols)) {
      return true;
    }

    if ((valid_symbols[EXAMPLE_FENCE_START] || valid_symbols[EXAMPLE_FENCE_END]) &&
        lexer->lookahead == '=' &&
        scan_repeated_fence(lexer, '=', 4)) {
      if (valid_symbols[EXAMPLE_FENCE_END]) {
        lexer->result_symbol = EXAMPLE_FENCE_END;
      } else {
        lexer->result_symbol = EXAMPLE_FENCE_START;
      }
      note_block_transition(state, lexer->result_symbol);
      return true;
    }

    if ((valid_symbols[LITERAL_FENCE_START] || valid_symbols[LITERAL_FENCE_END]) &&
        lexer->lookahead == '.' &&
        scan_repeated_fence(lexer, '.', 4)) {
      if (valid_symbols[LITERAL_FENCE_END]) {
        lexer->result_symbol = LITERAL_FENCE_END;
      } else {
        lexer->result_symbol = LITERAL_FENCE_START;
      }
      note_block_transition(state, lexer->result_symbol);
      return true;
    }

    if ((valid_symbols[QUOTE_FENCE_START] || valid_symbols[QUOTE_FENCE_END]) &&
        lexer->lookahead == '_' &&
        scan_repeated_fence(lexer, '_', 4)) {
      if (valid_symbols[QUOTE_FENCE_END]) {
        lexer->result_symbol = QUOTE_FENCE_END;
      } else {
        lexer->result_symbol = QUOTE_FENCE_START;
      }
      note_block_transition(state, lexer->result_symbol);
      return true;
    }

    if (valid_symbols[ORDERED_LIST_MARKER] && scan_ordered_list_marker(lexer)) {
      return true;
    }
  }

  if (state && state->block_depth > 0 && valid_symbols[DELIMITED_BLOCK_CONTENT_LINE] &&
      lexer->lookahead != 0 &&
      !is_newline(lexer->lookahead) &&
      scan_block_content_line(lexer)) {
    lexer->result_symbol = DELIMITED_BLOCK_CONTENT_LINE;
    return true;
  }

  if (scan_internal_xref_open(lexer, valid_symbols)) {
    return true;
  }

  if (scan_internal_xref_close(lexer, valid_symbols)) {
    return true;
  }

  if (scan_plain_inline_punctuation(lexer, valid_symbols, state)) {
    return true;
  }

  return false;
}
